{
  "task": {
    "title": "Дерево комментариев",
    "number": "10",
    "score": "45",
    "testExamples": [
      {
        "input": "4\n14\n75 22 I'm fine. Thank you.\n84 82     Ciao!\n26 22 So-so\n45 26 What's wrong?\n22 -1 How are you?\n72 45 Maybe I got sick\n81 72 I wish you a speedy recovery!\n97 26   Stick it!\n2 97 Thanks\n47 72 I also got sick recently.\n25 -1 Hi!\n82 -1 Bye\n17 82 Good day!\n29 72 Visit the doctor\n8\n5 4 e\n6 5 f\n7 6 g\n1 -1 a\n2 1 b\n3 2 c\n4 3 d\n8 7 h\n6\n10 -1 x\n20 10 x\n40 -1 x\n50 -1 x\n11 20 x\n30 10 x\n1\n1000000000 -1 root\n",
        "output": "How are you?\n|\n|--So-so\n|  |\n|  |--What's wrong?\n|  |  |\n|  |  |--Maybe I got sick\n|  |     |\n|  |     |--Visit the doctor\n|  |     |\n|  |     |--I also got sick recently.\n|  |     |\n|  |     |--I wish you a speedy recovery!\n|  |\n|  |--  Stick it!\n|     |\n|     |--Thanks\n|\n|--I'm fine. Thank you.\n\nHi!\n\nBye\n|\n|--Good day!\n|\n|--    Ciao!\n\na\n|\n|--b\n   |\n   |--c\n      |\n      |--d\n         |\n         |--e\n            |\n            |--f\n               |\n               |--g\n                  |\n                  |--h\n\nx\n|\n|--x\n|  |\n|  |--x\n|\n|--x\n\nx\n\nx\n\nroot\n"
      }
    ],
    "userStatus": {
      "key": "SOLVED",
      "label": "Решена"
    },
    "condition": "Вам задан набор комментариев. Каждый комментарий описывается тремя параметрами:\n\n$\\bullet$ своим идентификатором (уникальное целое число от $1$ до $10^9$),\n$\\bullet$ идентификатором предка (или $\\texttt{-1}$, если предка нет),\n$\\bullet$ своим текстом (непустая строка из символов с кодами от $32$ до $126$, включительно).\n\nВыведите заданные комментарии в древесном виде, отформатировав их в точности так, как изображено в примерах.\n\nОбратите внимание, что для каждого комментария-родителя его детей надо выводить в порядке увеличения их идентификаторов. Иными словами, всех детей одного родителя надо упорядочивать по возрастанию их идентификаторов.\n\nВнимательно изучите примеры, точно следуйте всем особенностям форматирования (включая количество пробелов и т.п.). Вы можете выводить произвольное количество пробелов в конце строки. Например, при выводе <<$\\texttt{|  |  |}$>> допустимо вывести <<$\\texttt{|  |  |  }$>>.\n",
    "inputFormat": "stdin",
    "outputFormat": "stdout",
    "inputFormatDescription": "Входные данные состоят из одного или более набора входных данных. Наборы входных данных в тесте являются независимыми. Друг на друга они никак не влияют.\n\nВ первой строке записано целое число $t$ ($1 \\le t \\le 100$) — количество наборов входных данных в тесте.\n\nДалее следуют $t$ наборов входных данных.\n\nКаждый набор входных данных начинается строкой, которая содержит целое число $n$ ($1 \\le n \\le 200$) — количество комментариев.\n\nДалее заданы сами комментарии, по одному в строке. Каждая строка имеет вид <<$\\texttt{id p text}$>>, где $id$ — идентификатор комментария (уникальное целое число от $1$ до $10^9$), $p$ — идентификатор предка или $\\texttt{-1}$, если предка нет, $text$ — текст комментария в виде непустой строки длины не более $100$. Текст содержит только символами с кодами от $32$ до $126$.\n\nГарантируется, что заданные комментарии корректны — задают одно или более дерево комментариев (циклические зависимости запрещены, если указан родитель, то он существует).",
    "outputFormatDescription": "Выведите комментарии в виде деревьев. Между выводами для разных наборов входных данных выводите пустую строку. В точности следуйте примерам, ваш вывод должен в точности совпадать с выводом авторского решения.",
    "languages": ["GO"],
    "timeLimit": 4000,
    "memoryLimit": 256,
    "testArchiveUrl": "test-examples-taskbook-api/50.zip",
    "countOfSuccessSolvers": "48"
  }
}
